<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title></title>
    <style type="text/css">
        body,img{
            margin: 0;
            padding: 0;
        }
    </style>
</head>
<body>
图片的加载过程：当我们打开一个页面，HTML、CSS、js代码会从上到下加载，如果遇到
img标签，浏览器首先会通过src里面存储的url地址向服务器 发送一个请求，服务器把对应的图片fan
返回给浏览器根据返回的内容把对应的图片，图片的延迟加载处理，先给img一个默认的图片
（非常的小，最好维持在10kb以内）当页面加载完成后再把真是的图片加载，或者开始只加载
第一屏幕的真是图片。在项目中两个都要做，默认的图
<script type="text/javascript">
    window.onload=function(){
        问题如果真是的图片不能加载，我们的真实图片会变成一张碎图，在IE下更难看
        是一张大叉，对于如果不能正常的话，我们，验证真是的图片能不能正常的加载
        var oTmg=new Image//->document.把真实的地址赋值给我们新创建的标签，此时这个标还为加载到如果图片能够正常的加载就会执行onload事件，先输出OK在输因为所有的时间
    }
   /* 当页面上的HTML结构，图片，文字等所有的资源都加载完成，在执行对应的事件绑定都是异步的
   对于图片没有在第一屏幕的我们当滚动条滚动到对应的区域（图片的底边也完全显示在页面中了）
   当随着滚动条的滚动，我们浏览器底边框当前图片底边框用offset获取当前元素的上边框距离
   获取当前图片底边距离body的上偏移
   var 获取当前浏览器一屏幕的高度window.onscroll=function(){
   var curT=document}浏览器的底边框高度大于盒子底边框的高度说明图片已经完边框还有问题s
   多张加载
    方法，*///公有属性在实例浏览器内置的属性是属于不可枚举的属性
    //继承：子类继承父类中的属性和方法（私有的和共有的）

    //核心原理：和生活中儿子继承爹的基因原理是不一样的原型继承并不是把父类的属性和方法克隆一份到自己
    //这，只是改变了原有的原型的指向，当我们
    //2.关于我们的重写，子类重写父类的方法，b.aa=function(){}-->写在b的私有属性上
            //冒充对象执行
    //在子类B的函数体中，创建父类A的一个实例
    //混合模式继承混合继承是call继承+原型继承
</script>
</body>
</html>